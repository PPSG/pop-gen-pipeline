## Table of Contents
[Whole-genome pop gen sequencing overview](#overview)<br>
[Experimental design](#design)<br>
[Compute access / Odyssey](#odyssey)<br>
[Sequence reads](#reads)<br>
[Quality control](#qc)<br>
[Preprocessing](#preprocess)<br>
[Indel Realignment](#realignment)<br>
[Variant Calling](#variantcalling)<br>
[Data Filtering](#filtering)<br>
[Next steps](#next)<br>
[References](#references)<br>

## Whole-genome population genomics resequencing overview <a name="overview"></a>


## Experimental design <a name="design"></a>


## Compute acces / Odyssey <a name="odyssey"></a>

This tutorial assumes that you have an account on the [Odyssey computer cluster](https://www.rc.fas.harvard.edu/training/introduction-to-odyssey-online/), which can be requested [here](https://portal.rc.fas.harvard.edu/request/account/new).

Programs, like those listed below (e.g. FastQC, Bowtie2, MACS2), are run on Odyssey by submitting jobs via the [SLURM management system](https://www.rc.fas.harvard.edu/resources/running-jobs/).
The jobs take the form of shell scripts, which are submitted with the [sbatch command](https://www.rc.fas.harvard.edu/resources/running-jobs/#Submitting_batch_jobs_using_the_sbatch_command).  The shell scripts request computational resources (time, memory, and number of cores) for a job; it is better to request more resources than expected, rather than risk having a job terminated prematurely for exceeding its limits. When running many jobs, it is also good practice to run a small subset to better understand the resource use for these jobs, and tailor your requests for the full panel.

### Running the GATK/PicardTools Pipeline on Odyssey

A few notes on running **GATK** and **PicardTools** commands on Odyssey. These programs are built with java, and so when running the *jar* file (e.g. `java -jar picard.jar Command`), you can include a few extra [options](https://docs.oracle.com/javase/7/docs/technotes/tools/windows/java.html) to pass to java that are especially applicable to running these programs on Odyssey. First, you can add a memory limit to java, for example requirign java to use no more than 4GB memory: `-Xmx4g`. This can help ensure your program does not use more memory than you request, resulting in job termination.

The second is: `-XX:ParallelGCThreads=1`. This command limits the number of java "Garbage Collector" threads running for each task. Based on what you set this number to be (we recommend 1 or 2), you should make sure to request that that number +1 for the number of cores you request in your submission script (e.g. `-n 2`). If you do not request this, java will start using many threads, and may cause your script to unexpectedly fail.

An examle PicardTools command with these two variables is: 

    java -Xmx4g -XX:ParallelGCThreads=1 -jar ~/path/to/picard.jar Command

## Sequence reads <a name="reads"></a>

The **fastq** format is a common way to store sequence reads, each read is represented by four lines:

1. **`@SeqID`** (instrument, flowcell lane, and then positioning info for where on the lane, sequence ID if multiplexed, and pair info (1/2)
2. **Sequence** (ATCG)
3. **`+`** (may have sequence identifier)
4. **Quality scores** ([Phred score](https://en.wikipedia.org/wiki/Phred_quality_score), probability that a base call is incorrect), encoded by characters

The `@Seqid` can be used to glean information about the sequencing run. For example, from this file created on the Illumina HiSeq 2500 here at the Bauer Core:

    @HISEQ2500:148:C9ECWANXX:8:1101:1338:2248 1:N:0:ATGACT

Breaking down this information, we have:

    INSTRUMENT:RUN_ID:FLOWCELL_BARCODE:LANE:TILE_NUMBER:X_COORD_CLUSTER:Y_COORD_CLUSTER 
    MEMBER_OF_PAIR(paired-end only):IS_READ_FILTERED(Y=yes,N=no):ARE_CONTROL_BITS_ON(0=No,even number otherise):INDEX_SEQUENCE
    
## Quality control <a name="qc"></a>

FastQC

## Preprocessing <a name="preprocess"></a>

Preprocessing sequencing reads is much simpler when dealing with resequencing data compared to building a genome. Most resequencing libraries will be created with large enough insert sizes so that paired-end reads will not overlap, and adapter contamination is not an issue (however, if this is not the case with your data, please visit the options for adapter removal in the [ATAC-seq workflow](https://informatics.fas.harvard.edu/peak-calling-workflow.html#qc)). 

Note that if for these reasons you also have many overlapping reads, in addition to trimming adapters, you also might want to merge the reads into single fragments. If you plan to call variants with a tool like **HaplotypeCaller** from the GATK pipeline as we describe below, this is not necessary as the program will account for overlapping bases and not inflate the variant quality scores. However, if the program you plan to use does not account for overlapping bases (e.g. **ANGSD**) you may want to use software like **NGmerge** in *stitch mode*, created by the Informatics group, to merge the reads. 

    module load ATAC-seq
    NGmerge -1 <fastq_read_1> -2 <fastq_read_2> -o <output_fasta_name>

See the documentation for NGmerge `NGmerge -h` for additional parameter options, such as the number of threads to use.

Note that additional trimming with resequencing data is not usually necessary, as many variant callers (e.g. **HaplotypeCaller**) take quality scores into account. Others (e.g. **ANGSD**), can trim reads during the data filtering step. For that reason, we do not recommend trimming here.

Preprocessing workflow (make image): <br>
Map each lane of each sample separately<br>
Merge with deduplication<br>
Sort BAM file<br>
Create BAM index<br>
Gather alignment metrics<br>
Validate BAM<br>

### Read Group Identifiers

Read group identifiers are used to identify sequence data by sequencing technology (e.g. Illumina), flow cell, lane, sample ID, and library. Using these identifiers ensures that batch effects, or biases in the data that might have been introduced at different stages of the sequencing process can be properly accounted for. Detailed documentation on Read Groups can be found on the [GATK website](https://gatkforums.broadinstitute.org/gatk/discussion/6472/read-groups).

The most common and recommended read groups are:

* `ID` : **Read Group Identifier**<br>
    A unique identifier for each read group. The convention for illumina data is {FLOWCELL}.{LANE}.

* `PU`: **Platform Unit**<br>
    A sample/library specific identifer, specified with: {FLOWCELL_BARCODE}.{LANE}.{SAMPLE}. The *flowcell barcode* is a unique identifer for a flow cell, *lane* is the lane of that flowcell, and *sample* is the sample or library specific identifier.

* `SM`: **Sample**<br>
    The name of the sample represented by this read group. This will be the name used in the sample column of the VCF file.

* `PL`: **Platform**<br>
    The sequencing technology used to create the data. Current valid values: ILLUMINA, SOLID, LS454, HELICOS, and PACBIO.

* `LB`: **Data Preparation Library Identifier**<br>
    The library preparation identifier. This is used by MarkDuplicates to identify which read gropus contain molecular (e.g. PCR) duplicates.

The read group information can be found in the file header (look for `@RG`) and the `RG:Z` tag for each sequence record. This information is not automatically added to Fastq files following sequencing, but needs to be added either when mapping with **BWA** or separately after mapping with Picard's [AddOrReplaceReadGroups](http://broadinstitute.github.io/picard/command-line-overview.html#AddOrReplaceReadGroups) tool.
 
If you don't know the information on the flowcell and lane for your data, you can derive the information from the sequence headers found in a Fastq file, as described in the [Sequence reads](#reads) section.

### Mapping reads to a reference genome

Once you have your reads, you need to map them to a reference genome. There are many different aligners out there (e.g. [BWA](http://bio-bwa.sourceforge.net) or [bowtie2](http://bowtie-bio.sourceforge.net/bowtie2/index.shtml)), but we recommend using **BWA** so that read group information can be added during the alignment stage, without requiring a separate step with Picard's [AddOrReplaceReadGroups](http://broadinstitute.github.io/picard/command-line-overview.html#AddOrReplaceReadGroups) tool.

Before you can align your reads to a reference genome, you need to create an index. This only needs to be completed once per reference genome. BWA indexes are made from a FASTA genome file using `bwa index`:

    bwa index -p <genome_prefix> <reference.fasta>

The genome prefix should be a short identifier to be used as the prefix for all output files (e.g. `prefix.bwt`).

For most resequencing data, we want to use the `bwa mem` algorithm (for 70bp to 1Mbp query sequences) to map our reads. A typical command would be:

    bwa mem -M -t 1 -R '@RG\tID:{FLOWCELL}.{LANE}\tPU:{FLOWCELL_BARCODE}.{LANE}.{SAMPLE}\tSM:{SAMPLE}\tPL:{PLATFORM}\tLB{LIBRARY}' <genome_prefix> <reads_1.fq> <reads_2.fq> > <samplename_bwa.sam>

There are many arguments available to use, as you can read in the [manual](http://bio-bwa.sourceforge.net/bwa.shtml). Some of the key arguments for these purposes are:

| Argument   | Description                                  |
|:----------:|----------------------------------------------|
| `-M`       | Mark shorter split hits as secondary - mandantory for Picard compatibility |
| `-t <int>` | Number of threads (default 1) |
| `-R <str>` | Read group information (see above for description) |
| `-p`       | Specifies that fastq read 1 and read 2 files are interleaved, if only one fastq is specified and this command is not used, will assume single-end data |

The output file format from BWA is a SAM (Sequence Alignment/Map) file format. This is a common file format, and [detailed documentation](https://samtools.github.io/hts-specs/SAMv1.pdf) can be found on the Samtools website. **[Samtools](http://www.htslib.org)** is part of a useful set of programs written to interact with high throughput sequencing data. The details of all you can do with this program are beyond the scope of this tutorial, but this program can be used to view, merge, calculate the depth of coverage, calculate other statistics, and index SAM-style files among other things.

### Sorting and Indexing

Following alignment, you will need to sort the SAM file. We also recommend you store these types of alignment files in BAM format, which is similar to SAM format, but its binary equivalent, and therefore compressed and more efficient. As mentioned above, **[Samtools](http://www.htslib.org)** can be used to convert among file types, but we are working within the GATK pipeline for this tutorial, and so will work within the GATK/PicardTools universe. 

You can automatically sort your SAM file by coordinate position (required for downstream analyses) and output the file in BAM format with PicardTools **[SortSam](http://broadinstitute.github.io/picard/command-line-overview.html#SortSam)** command. 

    java -jar ~/path/to/picard.jar SortSam \
    I=samplename_bwa.sam \
    O=samplename_sorted.bam \
    SORT_ORDER=coordinate

To use this BAM file, you also need to create a BAM index, so that software can efficiently access the compressed file. We do this with the **[BuildBamIndex](http://broadinstitute.github.io/picard/command-line-overview.html#BuildBamIndex)** command.

    java -jar ~/path/to/picard.jar BuildBamIndex \
    I=samplename_sorted.bam

### Alignment Metrics

It may also be useful to calculate metrics on the aligned sequences. We can easily do this with the **[CollectAlignmentSummaryMetrics](http://broadinstitute.github.io/picard/command-line-overview.html#CollectAlignmentSummaryMetrics)** tool. Note that this tools can also simultaneously creat a BAM index using the `CREATE_INDEX=TRUE` option and replace the previous command if not yet run. Note that you can collect the alignment metrics on several different levels. In the below example, I've included metrics both at the sample and read group level. You also need to include the reference fasta file.

    java -jar ~/path/to/picard.jar CollectAlignmentSummaryMetrics \
    I=samplename_sorted.bam \
    R=reference.fasta \
    METRIC_ACCUMULATION_LEVEL=SAMPLE \
    METRIC_ACCUMULATION_LEVEL=READ_GROUP \
    O=samplename.alignment_metrics.txt

### Deduplication

Following alignment, it is necessary to identify any duplicate sequences from the same DNA fragment in your files that occur due to sample preparation (e.g. during PCR) or incorrect optical cluster identification during sequencing. This possibility is why it is important to identify read groups for different lanes of the same sample. This is also a useful point to merge together any BAM files from the same sample that are currently separated (demonstrated in example below). We identify duplicate sequences with **[MarkDuplicates](https://broadinstitute.github.io/picard/command-line-overview.html#MarkDuplicates)**, and additional details on how this is performed can be found in the tool documentation. 

Note that it is not recommended to actually remove the duplicate sequences from the file, but simply to mark the flags appropriately in the BAM file, so that those sequences are ignored downstream. If using tools other than those we recommend here, make sure they can identify these flags. These sequences can also be removed later should the need arise.

    java -jar ~/path/to/picard.jar MarkDuplicates \
    TMP_DIR=tmp \
    I=samplename_sorted_file1.bam \
    I=samplename_sorted_file2.bam \
    O=samplename.dedup.bam \
    METRICS_FILE=samplename.dedup.metrics.txt \
    REMOVE_DUPLICATES=false \
    TAGGING_POLICY=ALL

We also recommend creating a deduplications metrics file, which will report the proportion and type of duplicate sequences in your sample and read groups.

***Following deduplication make sure to sort and index your file, as shown in the above section.***

### Validating BAM file

Once you are done with the above steps, it is best practice to validate your BAM file, to make sure there were not issues or mistakes associated with previous analyses. This is done with **[ValidateSamFile](http://broadinstitute.github.io/picard/command-line-overview.html#ValidateSamFile)**.

    java -jar ~/path/to/picard.jar ValidateSamFile \
    I=sample.dedup.sorted.bam \
    O=sample.validate.txt \
    MODE=SUMMARY

## Indel realignment <a name="realignment"></a>


## Variant calling <a name="variantcalling"></a>


## Data filtering <a name="filtering"></a>


## Next steps <a name="next"></a>


## References <a name="references"></a>


